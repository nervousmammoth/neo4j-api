---
**Status:** To Do
**Priority:** P0
**Branch:** `feature/P0.3-Setup-Tests-Structure`
---

## Overview

Setup Tests Directory Structure
**Phase:** 0 - Foundation

Create the `tests/` directory structure with `conftest.py` and placeholder test files. This establishes the pytest testing framework skeleton that will be populated with unit tests in subsequent issues following TDD approach.

## Related Specifications
- [ ] **Reference:** `CLAUDE.md` - Architecture section (lines 54-56)
- [ ] **Reference:** `IMPLEMENTATION_PLAN.md` - Testing structure
- [ ] **Reference:** `pyproject.toml` - Pytest and coverage configuration

## Related BDD Tests
N/A - Test structure setup task

## Dependencies
- [ ] Issue P0.2 - App structure must exist first (to know what to test)

---

## TDD Workflow Checklist

### 1ï¸âƒ£ Structure Task (No Tests Required)
- [ ] Review pytest best practices
- [ ] Review planned test structure from IMPLEMENTATION_PLAN.md
- [ ] Review pytest fixtures needed

### 2ï¸âƒ£ Create Directory Structure
- [ ] Create `tests/` root directory
- [ ] Create `tests/__init__.py`

### 3ï¸âƒ£ Create conftest.py with Fixtures
- [ ] Create `tests/conftest.py`
- [ ] Add pytest imports
- [ ] Add fixture for TestClient
- [ ] Add fixture for mock Neo4j driver
- [ ] Add fixture for API key
- [ ] Add fixture for mock settings/config
- [ ] Add docstrings for all fixtures

### 4ï¸âƒ£ Create Placeholder Test Files
- [ ] Create `tests/test_health.py` (empty with docstring)
- [ ] Create `tests/test_auth.py` (empty with docstring)
- [ ] Create `tests/test_validators.py` (empty with docstring)
- [ ] Create `tests/test_query.py` (empty with docstring)
- [ ] Create `tests/test_search.py` (empty with docstring)
- [ ] Create `tests/test_nodes.py` (empty with docstring)
- [ ] Create `tests/test_schema.py` (empty with docstring)
- [ ] Create `tests/test_config.py` (empty with docstring)
- [ ] Create `tests/test_neo4j_client.py` (empty with docstring)

### 5ï¸âƒ£ Verification
- [ ] Verify all test files exist
- [ ] Run pytest (should discover 0 tests)
- [ ] Verify fixtures are discovered
- [ ] Run pre-commit hooks

---

## Acceptance Criteria

### Functional Requirements
- [ ] `tests/` directory exists
- [ ] `tests/__init__.py` created
- [ ] `tests/conftest.py` with reusable fixtures
- [ ] All planned test files created (empty but with docstrings)
- [ ] Pytest can discover test directory
- [ ] Fixtures are available to all test files

### Non-Functional Requirements
- [ ] Follows pytest conventions
- [ ] Clean fixture organization
- [ ] Comprehensive fixture docstrings
- [ ] Type hints on fixtures
- [ ] No linting errors

---

## Implementation Notes

### Directory Structure to Create

```
tests/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ conftest.py                 # Pytest fixtures (shared across all tests)
â”œâ”€â”€ test_config.py              # Tests for app/config.py
â”œâ”€â”€ test_auth.py                # Tests for authentication/dependencies
â”œâ”€â”€ test_validators.py          # Tests for query validation
â”œâ”€â”€ test_neo4j_client.py        # Tests for Neo4j client wrapper
â”œâ”€â”€ test_health.py              # Tests for health endpoints
â”œâ”€â”€ test_search.py              # Tests for search endpoints
â”œâ”€â”€ test_query.py               # Tests for query execution
â”œâ”€â”€ test_nodes.py               # Tests for node operations
â””â”€â”€ test_schema.py              # Tests for schema endpoints
```

### conftest.py Template

```python
"""Pytest configuration and shared fixtures.

This module provides reusable fixtures for all test files, including:
- TestClient for API testing
- Mock Neo4j driver
- API key authentication
- Mock settings/configuration
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, AsyncIterator, Iterator
from unittest.mock import AsyncMock, MagicMock, Mock

import pytest
from fastapi.testclient import TestClient

if TYPE_CHECKING:
    from neo4j import AsyncDriver, Driver

# =============================================================================
# Configuration Fixtures
# =============================================================================

@pytest.fixture
def mock_settings() -> dict[str, Any]:
    """Mock application settings.

    Returns:
        Dictionary with mock configuration values for testing.
    """
    return {
        "neo4j_uri": "bolt://localhost:7687",
        "neo4j_username": "neo4j",
        "neo4j_password": "password",
        "neo4j_database": "neo4j",
        "api_key": "test-api-key-12345",
        "api_title": "Neo4j API Test",
        "api_version": "1.0.0",
        "api_prefix": "/api",
    }

@pytest.fixture
def api_key() -> str:
    """Valid API key for authentication tests.

    Returns:
        Test API key string.
    """
    return "test-api-key-12345"

@pytest.fixture
def invalid_api_key() -> str:
    """Invalid API key for negative authentication tests.

    Returns:
        Invalid API key string.
    """
    return "invalid-key"

# =============================================================================
# Neo4j Driver Fixtures
# =============================================================================

@pytest.fixture
def mock_neo4j_session() -> Mock:
    """Mock Neo4j session.

    Returns:
        Mock session object with common methods.
    """
    session = Mock()
    session.run = Mock()
    session.close = Mock()
    return session

@pytest.fixture
def mock_neo4j_driver(mock_neo4j_session: Mock) -> Mock:
    """Mock Neo4j driver.

    Args:
        mock_neo4j_session: Mocked session from fixture.

    Returns:
        Mock driver object that returns mock session.
    """
    driver = Mock()
    driver.session = Mock(return_value=mock_neo4j_session)
    driver.verify_connectivity = Mock()
    driver.close = Mock()
    return driver

@pytest.fixture
def mock_async_neo4j_session() -> AsyncMock:
    """Mock async Neo4j session.

    Returns:
        AsyncMock session object with common async methods.
    """
    session = AsyncMock()
    session.run = AsyncMock()
    session.close = AsyncMock()
    return session

@pytest.fixture
def mock_async_neo4j_driver(mock_async_neo4j_session: AsyncMock) -> AsyncMock:
    """Mock async Neo4j driver.

    Args:
        mock_async_neo4j_session: Mocked async session from fixture.

    Returns:
        AsyncMock driver object that returns mock async session.
    """
    driver = AsyncMock()
    driver.session = AsyncMock(return_value=mock_async_neo4j_session)
    driver.verify_connectivity = AsyncMock()
    driver.close = AsyncMock()
    return driver

# =============================================================================
# FastAPI Client Fixtures
# =============================================================================

@pytest.fixture
def client(mock_neo4j_driver: Mock, api_key: str) -> Iterator[TestClient]:
    """FastAPI test client with mocked dependencies.

    This fixture will be implemented once app/main.py exists.
    It should:
    1. Import the FastAPI app
    2. Override Neo4j driver dependency with mock
    3. Override settings dependency with mock
    4. Return TestClient instance

    Args:
        mock_neo4j_driver: Mocked Neo4j driver.
        api_key: Test API key.

    Yields:
        TestClient instance for making test requests.
    """
    # Implementation will be added after app/main.py is created
    # from app.main import app
    # from app.dependencies import get_neo4j_driver, get_settings
    #
    # app.dependency_overrides[get_neo4j_driver] = lambda: mock_neo4j_driver
    # app.dependency_overrides[get_settings] = lambda: mock_settings
    #
    # with TestClient(app) as test_client:
    #     yield test_client
    #
    # app.dependency_overrides.clear()

    # Placeholder until app is implemented
    raise NotImplementedError("Client fixture requires app/main.py implementation")

# =============================================================================
# Data Fixtures
# =============================================================================

@pytest.fixture
def sample_node_data() -> dict[str, Any]:
    """Sample node data for testing.

    Returns:
        Dictionary representing a Neo4j node in Linkurious format.
    """
    return {
        "id": "123",
        "categories": ["Person"],
        "properties": {
            "name": "John Doe",
            "age": 30,
            "email": "john@example.com"
        }
    }

@pytest.fixture
def sample_edge_data() -> dict[str, Any]:
    """Sample edge/relationship data for testing.

    Returns:
        Dictionary representing a Neo4j relationship in Linkurious format.
    """
    return {
        "id": "456",
        "type": "KNOWS",
        "source": "123",
        "target": "789",
        "properties": {
            "since": "2020-01-01",
            "strength": 0.8
        }
    }

@pytest.fixture
def sample_cypher_query() -> str:
    """Sample read-only Cypher query.

    Returns:
        Valid read-only Cypher query string.
    """
    return "MATCH (n:Person) WHERE n.name = $name RETURN n LIMIT 10"

@pytest.fixture
def sample_write_query() -> str:
    """Sample write Cypher query (should be blocked).

    Returns:
        Write Cypher query string that should be rejected.
    """
    return "CREATE (n:Person {name: $name}) RETURN n"
```

### Template for Test Files

**tests/__init__.py:**
```python
"""Unit tests for the Neo4j API application.

This package contains pytest-based unit tests for all application modules.
All tests follow TDD principles and aim for 100% code coverage.
"""
```

**tests/test_config.py:**
```python
"""Unit tests for app/config.py configuration management.

Tests cover:
- Settings loading from environment
- Default values
- Validation
"""

from __future__ import annotations

# Tests will be added in issue #04
```

**tests/test_auth.py:**
```python
"""Unit tests for API key authentication.

Tests cover:
- Valid API key allows access
- Invalid API key denies access
- Missing API key denies access
- Public endpoints don't require auth
"""

from __future__ import annotations

# Tests will be added in issue #08
```

**tests/test_validators.py:**
```python
"""Unit tests for query validation utilities.

Tests cover:
- Read-only queries are allowed
- Write queries are blocked (CREATE, DELETE, MERGE, SET, REMOVE)
- Edge cases and complex queries
"""

from __future__ import annotations

# Tests will be added in issue #06
```

**tests/test_neo4j_client.py:**
```python
"""Unit tests for Neo4j client wrapper.

Tests cover:
- Connection establishment
- Connection pooling
- Multi-database support
- Error handling
"""

from __future__ import annotations

# Tests will be added in issue #05
```

**tests/test_health.py:**
```python
"""Unit tests for health endpoints.

Tests cover:
- GET /api/health - Health check
- GET /api/databases - Database list
- No authentication required for these endpoints
"""

from __future__ import annotations

# Tests will be added in issues #10-11
```

**tests/test_query.py:**
```python
"""Unit tests for query execution endpoint.

Tests cover:
- POST /api/{database}/graph/query - Cypher execution
- Query validation integration
- Parameterized queries
- Error handling
"""

from __future__ import annotations

# Tests will be added in issues #14-15
```

**tests/test_search.py:**
```python
"""Unit tests for search endpoints.

Tests cover:
- GET /api/{database}/search/node/full - Node search
- GET /api/{database}/search/edge/full - Edge search
- Fuzzy matching
- Pagination
"""

from __future__ import annotations

# Tests will be added in issues #18-19
```

**tests/test_nodes.py:**
```python
"""Unit tests for node operation endpoints.

Tests cover:
- GET /api/{database}/graph/nodes/{node_id} - Get node
- POST /api/{database}/graph/nodes/expand - Expand neighborhood
- GET /api/{database}/graph/nodes/count - Count nodes
- GET /api/{database}/graph/edges/count - Count edges
"""

from __future__ import annotations

# Tests will be added in issues #22-24
```

**tests/test_schema.py:**
```python
"""Unit tests for schema discovery endpoints.

Tests cover:
- GET /api/{database}/graph/schema/node/types - Node labels
- GET /api/{database}/graph/schema/edge/types - Relationship types
"""

from __future__ import annotations

# Tests will be added in issues #27-28
```

### Verification Steps

1. **Structure verification:**
```bash
find tests/ -name "*.py" | sort
```

2. **Pytest discovery:**
```bash
pytest --collect-only
# Should show 0 tests collected
```

3. **Fixture discovery:**
```bash
pytest --fixtures tests/
# Should list all fixtures from conftest.py
```

4. **Linting:**
```bash
ruff check tests/
black --check tests/
mypy tests/
```

---

## Git Workflow

### Start Issue
```bash
git checkout main
git pull origin main
git checkout -b feature/P0.3-setup-tests-structure
```

### During Development
```bash
# Create directory
mkdir -p tests

# Create and populate conftest.py
# ... (see implementation notes above)

# Create test file stubs
# ... (see implementation notes above)

# Verify pytest discovers tests (should be 0)
pytest --collect-only

# Verify fixtures
pytest --fixtures tests/

# Run code quality checks
black tests/
ruff check tests/ --fix
mypy tests/

# Stage and commit
git add tests/
git commit -m "test(P0.3): setup tests directory structure with conftest fixtures"

# Push
git push origin feature/P0.3-setup-tests-structure
```

### Create Pull Request
```bash
gh pr create \
  --title "test: setup tests directory structure" \
  --body "$(cat <<'EOF'
## Summary
- Created tests/ directory structure
- Added conftest.py with comprehensive fixtures
- Created placeholder test files for all modules
- Established pytest testing framework skeleton

## Changes
- Created tests/ directory with __init__.py
- Added conftest.py with fixtures:
  - TestClient fixture
  - Mock Neo4j driver fixtures
  - API key fixtures
  - Sample data fixtures
- Created placeholder test files:
  - test_config.py, test_auth.py
  - test_validators.py, test_neo4j_client.py
  - test_health.py, test_query.py
  - test_search.py, test_nodes.py, test_schema.py
- All files have docstrings and ready for TDD

## Testing
- [x] Directory structure created correctly
- [x] Pytest discovers test directory
- [x] Fixtures are available
- [x] No linting errors
- [x] 0 tests collected (as expected for empty test files)

## Closes
Closes #03

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"
```

### After Merge
```bash
mv issues/P0.3-setup-tests-structure.md issues/completed/
git checkout main
git pull origin main
```

---

## Verification Commands

```bash
# List test structure
find tests/ -name "*.py" | sort

# Count files (should be 10)
find tests/ -name "*.py" | wc -l

# Check pytest discovery
pytest --collect-only

# List available fixtures
pytest --fixtures tests/

# Verify no syntax errors
python3 -m py_compile tests/*.py

# Run linting
ruff check tests/
black --check tests/
mypy tests/

# Try running pytest (should pass with 0 tests)
pytest tests/ -v
```

---

## References
- **Pytest docs:** https://docs.pytest.org/
- **Pytest fixtures:** https://docs.pytest.org/en/stable/fixture.html
- **FastAPI testing:** https://fastapi.tiangolo.com/tutorial/testing/
- **Coverage config:** `pyproject.toml` - Tool.coverage settings

---

## Notes
- All test files are created empty with docstrings only
- Actual tests will be written following TDD in subsequent issues
- conftest.py provides reusable fixtures across all tests
- The `client` fixture is a placeholder until app/main.py exists
- Fixtures follow pytest best practices
- Type hints enable better IDE support
- Fixtures are documented for easy reuse
- This structure supports the 100% coverage requirement
